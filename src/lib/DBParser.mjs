// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_HashMapInt from "rescript/lib/es6/belt_HashMapInt.js";

var dbDict = [
  "1",
  "#1",
  "2",
  "#2",
  "3",
  "4",
  "#4",
  "5",
  "#5",
  "6",
  "#6",
  "7"
];

function replacer(str) {
  return str.replace(/【/g, "[").replace(/（/g, "(").replace(/】/g, "]").replace(/）/g, ")");
}

function parsefromString(operator, str) {
  var arr = str.split("");
  return arr.reduce((function (result, $$char, i) {
                var tone;
                switch ($$char) {
                  case "#" :
                      tone = undefined;
                      break;
                  case "(" :
                      tone = -1;
                      break;
                  case "[" :
                      tone = i > 0 && Caml_array.get(arr, i - 1 | 0) === "[" ? 2 : 1;
                      break;
                  case "{" :
                      tone = -2;
                      break;
                  case ")" :
                  case "]" :
                  case "}" :
                      tone = 0;
                      break;
                  default:
                    var index = dbDict.indexOf(i > 0 && Caml_array.get(arr, i - 1 | 0) === "#" ? "#" + $$char : $$char);
                    var item = index > -1 ? (
                        operator === "FallingTone" ? [
                            index < 1 ? result.tone - 1 | 0 : result.tone,
                            (index + 11 | 0) % 12,
                            $$char
                          ] : (
                            operator === "RisingTone" ? [
                                index > 10 ? result.tone + 1 | 0 : result.tone,
                                (index + 1 | 0) % 12,
                                $$char
                              ] : [
                                result.tone,
                                index,
                                $$char
                              ]
                          )
                      ) : [
                        result.tone,
                        index,
                        $$char
                      ];
                    result.list.push(item);
                    tone = undefined;
                }
                if (tone !== undefined) {
                  result.tone = tone;
                }
                return result;
              }), {
              list: [],
              tone: 0
            }).list;
}

function getListString(source) {
  var signMap = Belt_HashMapInt.make(3);
  Belt_HashMapInt.set(signMap, -2, [
        "{",
        "}"
      ]);
  Belt_HashMapInt.set(signMap, -1, [
        "(",
        ")"
      ]);
  Belt_HashMapInt.set(signMap, 1, [
        "[",
        "]"
      ]);
  Belt_HashMapInt.set(signMap, 2, [
        "[[",
        "]]"
      ]);
  return source.reduce((function (result, param, index) {
                var value = param[1];
                var tone = param[0];
                var pushSign = function (tone, picker) {
                  var val = Belt_HashMapInt.get(signMap, tone);
                  if (val !== undefined) {
                    result.list.push(Curry._1(picker, val));
                  }
                  
                };
                if (tone !== result.tone) {
                  pushSign(result.tone, (function (param) {
                          return param[1];
                        }));
                  pushSign(tone, (function (param) {
                          return param[0];
                        }));
                }
                var $$char = value > -1 ? Caml_array.get(dbDict, value) : param[2];
                result.list.push($$char);
                if (index === (source.length - 1 | 0)) {
                  pushSign(tone, (function (param) {
                          return param[1];
                        }));
                }
                result.tone = tone;
                if (result.overflow === false) {
                  result.overflow = tone > 2 || tone < -2;
                }
                return result;
              }), {
              list: [],
              overflow: false,
              tone: 0
            });
}

function modifiedTone(str, operator) {
  var match = getListString(parsefromString(operator, replacer(str)));
  var overflow = match.overflow;
  if (overflow) {
    return str;
  } else {
    return match.list.join("");
  }
}

export {
  dbDict ,
  replacer ,
  parsefromString ,
  getListString ,
  modifiedTone ,
}
/* No side effect */
